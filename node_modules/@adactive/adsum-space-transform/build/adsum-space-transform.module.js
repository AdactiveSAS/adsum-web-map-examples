/**
 * Copyright (C) 2018 Adactive SAS
 */

class AngleConverter{static toDegree(t){return 180*t/Math.PI}static toRadian(t){return t*Math.PI/180}}class WGS84{constructor(t,e,s){this.a=t,this.e=e,this.f=s,this.k0=.9996,this.ePow2=Math.pow(this.e,2),this.ePow4=Math.pow(this.e,4),this.ePow6=Math.pow(this.e,6),this.e1sq=this.ePow2/(1-this.ePow2)}static fromFlattening(t,e){return new this(t,Math.sqrt(2*e-Math.pow(e,2)),e)}}var WGS84$1=WGS84.fromFlattening(6378137,1/298.257223563);class UtmGridZone{constructor(t){this.k=WGS84$1.k0,this.E=5e5;const e=AngleConverter.toDegree(t.long);this.zone=e<0?Math.floor((180+e)/6+1):Math.floor(e/6+31),this.long=AngleConverter.toRadian(6*(this.zone-30)-3),this.N=t.lat<0?1e7:0,this.hemi=0===this.N?1:-1}}const S1=1-WGS84$1.ePow2/4-3/64*WGS84$1.ePow4-5/256*WGS84$1.ePow6,S2=3/8*WGS84$1.ePow2+3/32*WGS84$1.ePow4+45/1024*WGS84$1.ePow6,S3=15/256*WGS84$1.ePow4+45/1024*WGS84$1.ePow6,S4=35/3072*WGS84$1.ePow6;class GpsToUtmVariables{constructor(t,e=null){this.gps=t,this.utmGridZone=e||new UtmGridZone(this.gps),this.deltaLong=this.gps.long-this.utmGridZone.long,this.Nu=1/Math.sqrt(1-WGS84$1.ePow2*Math.pow(Math.sin(this.gps.lat),2)),this.A=this.deltaLong*Math.cos(this.gps.lat),this.APow2=Math.pow(this.A,2),this.APow3=Math.pow(this.A,3),this.APow4=Math.pow(this.A,4),this.APow5=Math.pow(this.A,5),this.APow6=Math.pow(this.A,6);const s=Math.sin(2*this.gps.lat),r=Math.sin(4*this.gps.lat),i=Math.sin(6*this.gps.lat);this.S=S1*this.gps.lat-S2*s+S3*r-S4*i,this.T=Math.pow(Math.tan(this.gps.lat),2),this.TPow2=Math.pow(this.T,2),this.C=WGS84$1.ePow2/(1-WGS84$1.ePow2)*Math.pow(Math.cos(this.gps.lat),2),this.CPow2=Math.pow(this.C,2),this.E=this.A+(1-this.T+this.C)/6*this.APow3,this.E+=(5-18*this.T+this.TPow2)*this.APow5/120,this.E*=this.utmGridZone.k*WGS84$1.a*this.Nu,this.E+=this.utmGridZone.E,this.N=this.APow2/2,this.N+=(5-this.T+9*this.C+4*this.CPow2)*this.APow4/24,this.N+=(61-58*this.T+this.TPow2)*this.APow6/720,this.N*=this.Nu*Math.tan(this.gps.lat),this.N+=this.S,this.N*=WGS84$1.a*this.utmGridZone.k,this.N+=this.utmGridZone.N}}class UtmToGpsVariables{constructor(t){let e=t.N;const s=1===t.hemi;s||(e=1e7-e);const r=e/WGS84$1.k0/(WGS84$1.a*(1-WGS84$1.e**2/4-3*WGS84$1.e**4/64-5*WGS84$1.e**6/256)),i=(1-(1-WGS84$1.ePow2)**.5)/(1+(1-WGS84$1.ePow2)**.5),n=21*i**2/16-55*i**4/32,o=151*i**3/96,a=1097*i**4/512,h=r+(3*i/2-27*i**3/32)*Math.sin(2*r)+n*Math.sin(4*r)+o*Math.sin(6*r)+a*Math.sin(8*r),c=WGS84$1.a/(1-(WGS84$1.e*Math.sin(h))**2)**.5,l=WGS84$1.a*(1-WGS84$1.ePow2)/(1-(WGS84$1.e*Math.sin(h))**2)**1.5,u=c*Math.tan(h)/l,g=5e5-t.E,m=g/(c*WGS84$1.k0),w=m*m/2,p=Math.tan(h)**2,x=WGS84$1.e1sq*Math.cos(h)**2,M=(5+3*p+10*x-4*x*x-9*WGS84$1.e1sq)*m**4/24,S=(61+90*p+298*x+45*p*p-252*WGS84$1.e1sq-3*x*x)*m**6/720,d=180*((g/(c*WGS84$1.k0)-(1+2*p+x)*m**3/6+(5-2*x+28*p-3*x**2+8*WGS84$1.e1sq+24*p**2)*m**5/120)/Math.cos(h))/Math.PI;this.latitude=180*(h-u*(w+M+S))/Math.PI,s||(this.latitude=-this.latitude);const f=t.zone>0?6*t.zone-183:3;this.longitude=f-d}}class Utm{constructor(t,e,s,r,i){this.E=t,this.N=e,this.alt=s,this.hemi=r,this.zone=i}}class Gps{constructor(t,e,s){this.lat=t,this.long=e,this.alt=s}static fromDegree(t,e,s){return new this(AngleConverter.toRadian(t),AngleConverter.toRadian(e),s)}get latInDegree(){return AngleConverter.toDegree(this.lat)}get longInDegree(){return AngleConverter.toDegree(this.long)}}class GpsToUtmConverter{static toUtm(t,e){const s=new GpsToUtmVariables(t,e);return new Utm(s.E,s.N,t.alt,s.utmGridZone.hemi,s.utmGridZone.zone)}static toGps(t){const e=new UtmToGpsVariables(t);return Gps.fromDegree(e.latitude,e.longitude,t.alt)}}class Matrix{constructor(t,e,s=null){this.n=t,this.m=e,null===s?(this.values=new Array(this.n*this.m),this.values.fill(0)):this.values=s}get(t,e){return this.values[this.getIndex(t,e)]}set(t,e,s){return this.values[this.getIndex(t,e)]=s,this}getIndex(t,e){if("number"!=typeof t||t>=this.n)throw new Error("Invalid row index");if("number"!=typeof e||e>=this.m)throw new Error("Invalid column index");return t*this.m+e}transpose(){const t=new Matrix(this.m,this.n);for(let e=0;e<this.n;e++)for(let s=0;s<this.m;s++)t.set(s,e,this.get(e,s));return t}multiply(t){if("number"!=typeof t)throw new Error("Expected a number");return this.values=this.values.map(e=>e*t),this}extractColumn(t){const e=new Matrix(this.n,1);for(let s=0;s<this.n;s++)e.set(s,0,this.get(s,t));return e}static sum(t,e){if(t.m!==e.m||t.n!==e.n)throw new Error("Invalid given matrices");return new Matrix(t.n,t.m,t.values.map((t,s)=>t+e.values[s]))}static identity(t){const e=new Matrix(t,t);for(let s=0;s<t;s++)e.set(s,s,1);return e}static additiveInverse(t){return new Matrix(t.n,t.m,t.values.map(t=>-1*t))}static product(t,e){if(!(t instanceof Matrix&&e instanceof Matrix))throw new Error("Expected two Matrices");if(t.m!==e.n)throw new Error("Invalid given matrices");const s=t.m,r=new Matrix(t.n,e.m);for(let i=0;i<r.n;i++)for(let n=0;n<r.m;n++){let o=0;for(let r=0;r<s;r++)o+=t.get(i,r)*e.get(r,n);r.set(i,n,o)}return r}static inverseMatrix3(t){if(3!==t.n||3!==t.m)throw new Error("Works only with Matrix 3");const e=t.extractColumn(0),s=t.extractColumn(1),r=t.extractColumn(2),i=this.determinantMatrix3(t);if(0===i)throw new Error("Not inversible matrix");const n=this.crossProductVector3(s,r).transpose().multiply(1/i),o=this.crossProductVector3(r,e).transpose().multiply(1/i),a=this.crossProductVector3(e,s).transpose().multiply(1/i),h=new Matrix(3,3);return h.set(0,0,n.get(0,0)),h.set(0,1,n.get(0,1)),h.set(0,2,n.get(0,2)),h.set(1,0,o.get(0,0)),h.set(1,1,o.get(0,1)),h.set(1,2,o.get(0,2)),h.set(2,0,a.get(0,0)),h.set(2,1,a.get(0,1)),h.set(2,2,a.get(0,2)),h}static determinantMatrix3(t){if(3!==t.n||3!==t.m)throw new Error("Works only with Matrix 3");const e=t.extractColumn(0),s=t.extractColumn(1),r=t.extractColumn(2);return Matrix.dotProductVector(e,Matrix.crossProductVector3(s,r))}static crossProductVector3(t,e){if(3!==t.n||1!==t.m||3!==e.n||1!==e.m)throw new Error("Works only with Matrix 3x1");const s=new Matrix(3,1);return s.set(0,0,t.get(1,0)*e.get(2,0)-t.get(2,0)*e.get(1,0)),s.set(1,0,t.get(2,0)*e.get(0,0)-t.get(0,0)*e.get(2,0)),s.set(2,0,t.get(0,0)*e.get(1,0)-t.get(1,0)*e.get(0,0)),s}static dotProductVector(t,e){if(1!==t.m||1!==e.m||t.n!==e.n)throw new Error("Works only with Matrix nx1");let s=0;for(let r=0;r<t.n;r++)s+=t.get(r,0)*e.get(r,0);return s}}class LinearSquareRegression{static compute2ParametersRegression(t){const e=t.length,s=new Matrix(e,3),r=new Matrix(e,1);for(let i=0;i<e;i++)s.set(i,0,1),s.set(i,1,t[i].parameters.get(0,0)),s.set(i,2,t[i].parameters.get(1,0)),r.set(i,0,t[i].result);const i=s.transpose();return Matrix.product(Matrix.product(Matrix.inverseMatrix3(Matrix.product(i,s)),i),r)}}class EuclideanSpaceTransform{constructor(t,e){this.transformMatrix=t,this.translateMatrix=e,this._reverseTransform=null}convert(t){const e=new Matrix(3,1,[t.x,t.y,t.z]),s=Matrix.sum(Matrix.product(this.transformMatrix,e),this.translateMatrix);return{x:s.get(0,0),y:s.get(1,0),z:s.get(2,0)}}revert(t){return this.reverseTransform.convert(t)}get reverseTransform(){if(null===this._reverseTransform){const t=Matrix.inverseMatrix3(this.transformMatrix),e=Matrix.additiveInverse(Matrix.product(t,this.translateMatrix));this._reverseTransform=new EuclideanSpaceTransform(t,e),this._reverseTransform._reverseTransform=this}return this._reverseTransform}getDistanceAverageError(t,e){const s=t.length;let r=0;for(let i=0;i<s;i++){const s=t[i],n=e[i];r+=this.constructor._getDistance(this.convert(s),n)}return r/s}getDistanceErrorRepartitionFromAverage(t,e){const s=t.length,r=this.getDistanceAverageError(t,e),i=new Array(10);i.fill(0);for(let n=0;n<s;n++){const s=t[n],o=e[n],a=this.constructor._getDistance(this.convert(s),o),h=Math.abs(r-a)/r*100;let c=Math.trunc(h/10);c>9&&(c=9),i[c]++}return i.map(t=>Math.floor(t/s*100))}getRelativeDistanceErrorFromAverage(t,e){const s=t.length,r=this.getDistanceAverageError(t,e),i=[];for(let n=0;n<s;n++){const s=t[n],o=e[n],a=this.constructor._getDistance(this.convert(s),o);i[n]=Math.abs(r-a)/r*100}return i}getAmplitudeError(t,e){const s=t.length,r={x:1/0,y:1/0,z:1/0},i={x:-1/0,y:-1/0,z:-1/0};for(let n=0;n<s;n++){const s=t[n],o=e[n],a=this.convert(s),h=Math.abs(a.x-o.x),c=Math.abs(a.y-o.y);h<r.x&&(r.x=h),h>i.x&&(i.x=h),c<r.y&&(r.y=c),c>i.y&&(i.y=c)}return{x:i.x-r.x,y:i.y-r.y}}static computeSample(t,e){return this._leastSquareComputeSample(t,e)}static _leastSquareComputeSample(t,e){const s=[];for(let r=0;r<t.length;r++){const i=[...t],n=[...e],o=i[r],a=n[r];i[r]=i[0],n[r]=n[0],i[0]=o,n[0]=a,s.push(this._leastSquareComputeSampleWithOrigin(i,n))}return this._selectResultLeastAverageDistanceError(s,t,e)}static _leastSquareComputeSampleWithOrigin(t,e){const s=[],r=[],i=t[0],n=e[0];for(let o=1;o<t.length;o++){const a=t[o],h=e[o],c=new Matrix(2,1);c.set(0,0,a.x-i.x),c.set(1,0,a.y-i.y);const l=new Matrix(2,1);l.set(0,0,h.x-n.x),l.set(1,0,h.y-n.y),s.push({parameters:c,result:l.get(0,0)}),r.push({parameters:c,result:l.get(1,0)})}const o=LinearSquareRegression.compute2ParametersRegression(s),a=LinearSquareRegression.compute2ParametersRegression(r),h=new Matrix(3,3);h.set(0,0,o.get(1,0)),h.set(0,1,o.get(2,0)),h.set(0,2,0),h.set(1,0,a.get(1,0)),h.set(1,1,a.get(2,0)),h.set(1,2,0),h.set(2,0,0),h.set(2,1,0),h.set(2,2,1);const c=new Matrix(3,1);return c.set(0,0,n.x+o.get(0,0)-o.get(1,0)*i.x-o.get(2,0)*i.y),c.set(1,0,n.y+a.get(0,0)-a.get(1,0)*i.x-a.get(2,0)*i.y),c.set(2,0,0),new EuclideanSpaceTransform(h,c)}static _linearComputeSample(t,e){const s=t.length,r=[];for(let i=0;i<s-2;i++){const n=t[i],o=e[i];for(let a=i+1;a<s-1;a++){const i=t[a],h=e[a];for(let c=a+1;c<s;c++){const s=t[c],a=e[c],l=this._linearComputeTripletSample(n,i,s,o,h,a);r.push(l)}}}return this._selectResultLeastAverageDistanceError(r,t,e)}static _linearComputeTripletSample(t,e,s,r,i,n){const o=e.x-t.x,a=e.y-t.y,h=s.x-t.x,c=s.y-t.y,l=i.x-r.x,u=i.y-r.y,g=((n.x-r.x)*o-l*h)/(c*o-h*a),m=((n.y-r.y)*o-u*h)/(c*o-h*a),w=(l-g*a)/o,p=(u-m*a)/o,x=new Matrix(3,3);x.set(0,0,w),x.set(0,1,g),x.set(0,2,0),x.set(1,0,p),x.set(1,1,m),x.set(1,2,0),x.set(2,0,0),x.set(2,1,0),x.set(2,2,1);const M=new Matrix(3,1);return M.set(0,0,r.x-w*t.x-g*t.y),M.set(1,0,r.y-p*t.x-m*t.y),M.set(2,0,0),new EuclideanSpaceTransform(x,M)}static _selectResultLeastAverageDistanceError(t,e,s){let r=null,i=1/0;if(!Array.isArray(t)||0===t.length)throw new Error("Expected a non empty array");return t.forEach(t=>{const n=t.getDistanceAverageError(e,s);n<i&&(r=t,i=n)}),r}static _getDistance(t,e){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}}export{Gps,Utm,GpsToUtmConverter as GpsUtmConverter,EuclideanSpaceTransform,UtmGridZone};
